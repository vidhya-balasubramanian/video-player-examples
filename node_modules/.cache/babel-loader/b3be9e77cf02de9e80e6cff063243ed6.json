{"ast":null,"code":"/*! @name @videojs/vhs-utils @version 2.3.0 @license MIT */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar isTypedArray = function isTypedArray(obj) {\n  return ArrayBuffer.isView(obj);\n};\n\nvar toUint8 = function toUint8(bytes) {\n  return bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n};\n\nvar bytesToString = function bytesToString(bytes) {\n  if (!bytes) {\n    return '';\n  }\n\n  bytes = Array.prototype.slice.call(bytes);\n  var string = String.fromCharCode.apply(null, toUint8(bytes));\n\n  try {\n    return decodeURIComponent(escape(string));\n  } catch (e) {// if decodeURIComponent/escape fails, we are dealing with partial\n    // or full non string data. Just return the potentially garbled string.\n  }\n\n  return string;\n};\n\nvar stringToBytes = function stringToBytes(string, stringIsBytes) {\n  if (stringIsBytes === void 0) {\n    stringIsBytes = false;\n  }\n\n  var bytes = [];\n\n  if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n    string = string.toString();\n  }\n\n  if (typeof string !== 'string') {\n    return bytes;\n  } // If the string already is bytes, we don't have to do this\n\n\n  if (!stringIsBytes) {\n    string = unescape(encodeURIComponent(string));\n  }\n\n  return string.split('').map(function (s) {\n    return s.charCodeAt(0) & 0xFF;\n  });\n};\n\nvar concatTypedArrays = function concatTypedArrays() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  var totalLength = buffers.reduce(function (total, buf) {\n    var len = buf && (buf.byteLength || buf.length);\n    total += len || 0;\n    return total;\n  }, 0);\n  var tempBuffer = new Uint8Array(totalLength);\n  var offset = 0;\n  buffers.forEach(function (buf) {\n    buf = toUint8(buf);\n    tempBuffer.set(buf, offset);\n    offset += buf.byteLength;\n  });\n  return tempBuffer;\n};\n\nexports.bytesToString = bytesToString;\nexports.concatTypedArrays = concatTypedArrays;\nexports.isTypedArray = isTypedArray;\nexports.stringToBytes = stringToBytes;\nexports.toUint8 = toUint8;","map":{"version":3,"sources":["/home/ubuntu/Documents/video-player-examples/node_modules/@videojs/vhs-utils/dist/byte-helpers.js"],"names":["Object","defineProperty","exports","value","isTypedArray","obj","ArrayBuffer","isView","toUint8","bytes","Uint8Array","buffer","byteOffset","byteLength","bytesToString","Array","prototype","slice","call","string","String","fromCharCode","apply","decodeURIComponent","escape","e","stringToBytes","stringIsBytes","toString","unescape","encodeURIComponent","split","map","s","charCodeAt","concatTypedArrays","_len","arguments","length","buffers","_key","totalLength","reduce","total","buf","len","tempBuffer","offset","forEach","set"],"mappings":"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","sourcesContent":["/*! @name @videojs/vhs-utils @version 2.3.0 @license MIT */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar isTypedArray = function isTypedArray(obj) {\n  return ArrayBuffer.isView(obj);\n};\nvar toUint8 = function toUint8(bytes) {\n  return bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n};\nvar bytesToString = function bytesToString(bytes) {\n  if (!bytes) {\n    return '';\n  }\n\n  bytes = Array.prototype.slice.call(bytes);\n  var string = String.fromCharCode.apply(null, toUint8(bytes));\n\n  try {\n    return decodeURIComponent(escape(string));\n  } catch (e) {// if decodeURIComponent/escape fails, we are dealing with partial\n    // or full non string data. Just return the potentially garbled string.\n  }\n\n  return string;\n};\nvar stringToBytes = function stringToBytes(string, stringIsBytes) {\n  if (stringIsBytes === void 0) {\n    stringIsBytes = false;\n  }\n\n  var bytes = [];\n\n  if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n    string = string.toString();\n  }\n\n  if (typeof string !== 'string') {\n    return bytes;\n  } // If the string already is bytes, we don't have to do this\n\n\n  if (!stringIsBytes) {\n    string = unescape(encodeURIComponent(string));\n  }\n\n  return string.split('').map(function (s) {\n    return s.charCodeAt(0) & 0xFF;\n  });\n};\nvar concatTypedArrays = function concatTypedArrays() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n\n  var totalLength = buffers.reduce(function (total, buf) {\n    var len = buf && (buf.byteLength || buf.length);\n    total += len || 0;\n    return total;\n  }, 0);\n  var tempBuffer = new Uint8Array(totalLength);\n  var offset = 0;\n  buffers.forEach(function (buf) {\n    buf = toUint8(buf);\n    tempBuffer.set(buf, offset);\n    offset += buf.byteLength;\n  });\n  return tempBuffer;\n};\n\nexports.bytesToString = bytesToString;\nexports.concatTypedArrays = concatTypedArrays;\nexports.isTypedArray = isTypedArray;\nexports.stringToBytes = stringToBytes;\nexports.toUint8 = toUint8;\n"]},"metadata":{},"sourceType":"script"}