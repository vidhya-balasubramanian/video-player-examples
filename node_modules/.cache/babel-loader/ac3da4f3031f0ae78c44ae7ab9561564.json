{"ast":null,"code":"/*! @name m3u8-parser @version 4.5.0 @license Apache-2.0 */\nimport _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport Stream from '@videojs/vhs-utils/dist/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/dist/decode-b64-to-uint8-array.js';\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nvar LineStream = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(LineStream, _Stream);\n\n  function LineStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.buffer = '';\n    return _this;\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  var _proto = LineStream.prototype;\n\n  _proto.push = function push(data) {\n    var nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nvar ParseStream = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(ParseStream, _Stream);\n\n  function ParseStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.customParsers = [];\n    _this.tagMappers = [];\n    return _this;\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  var _proto = ParseStream.prototype;\n\n  _proto.push = function push(line) {\n    var _this2 = this;\n\n    var match;\n    var event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    var newLines = this.tagMappers.reduce(function (acc, mapper) {\n      var mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(function (newLine) {\n      for (var i = 0; i < _this2.customParsers.length; i++) {\n        if (_this2.customParsers[i].call(_this2, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        _this2.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n\n        return;\n      }\n\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'totalduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'byterange'\n        };\n\n        if (match[1]) {\n          event.length = parseInt(match[1], 10);\n        }\n\n        if (match[2]) {\n          event.offset = parseInt(match[2], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n                length = _attributes$BYTERANGE[0],\n                offset = _attributes$BYTERANGE[1];\n\n            event.byterange = {};\n\n            if (length) {\n              event.byterange.length = parseInt(length, 10);\n            }\n\n            if (offset) {\n              event.byterange.offset = parseInt(offset, 10);\n            }\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-START:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      } // unknown tag type\n\n\n      _this2.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(_ref) {\n    var _this3 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this3.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(_ref2) {\n    var expression = _ref2.expression,\n        map = _ref2.map;\n\n    var mapFn = function mapFn(line) {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  };\n\n  return ParseStream;\n}(Stream);\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\n\nvar Parser = /*#__PURE__*/function (_Stream) {\n  _inheritsLoose(Parser, _Stream);\n\n  function Parser() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n\n\n    var self = _assertThisInitialized(_this);\n    /* eslint-enable consistent-this */\n\n\n    var uris = [];\n    var currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    var currentMap; // if specified, the active decryption key\n\n    var _key;\n\n    var noop = function noop() {};\n\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    var lastByterangeEnd = 0; // update the manifest with the m3u8 entry from the parse stream\n\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup;\n      var rendition;\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = {\n                  'com.widevine.alpha': {\n                    attributes: {\n                      schemeIdUri: entry.attributes.KEYFORMAT,\n                      // remove '0x' from the key id string\n                      keyId: entry.attributes.KEYID.substring(2)\n                    },\n                    // decode the base64-encoded PSSH box\n                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                  }\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.totalDuration = entry.duration;\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (_key) {\n            currentUri.key = _key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n        comment: function comment() {// comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n  ;\n\n  _proto.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  };\n\n  return Parser;\n}(Stream);\n\nexport { LineStream, ParseStream, Parser };","map":{"version":3,"sources":["/home/ubuntu/Documents/video-player-examples/node_modules/m3u8-parser/dist/m3u8-parser.es.js"],"names":["_inheritsLoose","Stream","_extends","_assertThisInitialized","decodeB64ToUint8Array","LineStream","_Stream","_this","call","buffer","_proto","prototype","push","data","nextNewline","indexOf","trigger","substring","attributeSeparator","key","value","keyvalue","RegExp","parseAttributes","attributes","attrs","split","result","i","length","attr","exec","slice","replace","ParseStream","customParsers","tagMappers","line","_this2","match","event","trim","type","uri","newLines","reduce","acc","mapper","mappedLine","concat","forEach","newLine","text","tagType","duration","parseFloat","title","parseInt","version","number","playlistType","offset","allowed","test","URI","BYTERANGE","_attributes$BYTERANGE","byterange","RESOLUTION","resolution","width","height","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","toLowerCase","Uint32Array","PRECISE","addParser","_ref","_this3","expression","customType","dataParser","segment","addTagMapper","_ref2","map","mapFn","Parser","lineStream","parseStream","pipe","self","uris","currentUri","currentMap","_key","noop","defaultMediaGroups","widevineUuid","currentTimeline","manifest","allowCache","discontinuityStarts","segments","lastByterangeEnd","on","entry","mediaGroup","rendition","tag","message","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","VALID_METHODS","KEYID","contentProtection","schemeIdUri","keyId","pssh","method","iv","isFinite","playlist","streamInf","playlists","mediaGroups","media","TYPE","NAME","mediaGroupType","default","DEFAULT","autoselect","AUTOSELECT","LANGUAGE","language","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","programDateTime","targetduration","targetDuration","totalduration","totalDuration","start","isNaN","timeOffset","precise","cueOut","cueOutCont","cueIn","timeline","comment","custom","chunk","end","options"],"mappings":"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","sourcesContent":["/*! @name m3u8-parser @version 4.5.0 @license Apache-2.0 */\nimport _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport Stream from '@videojs/vhs-utils/dist/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/dist/decode-b64-to-uint8-array.js';\n\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nvar LineStream =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(LineStream, _Stream);\n\n  function LineStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.buffer = '';\n    return _this;\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  var _proto = LineStream.prototype;\n\n  _proto.push = function push(data) {\n    var nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  };\n\n  return LineStream;\n}(Stream);\n\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\nvar attributeSeparator = function attributeSeparator() {\n  var key = '[^=]*';\n  var value = '\"[^\"]*\"|[^,]*';\n  var keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nvar parseAttributes = function parseAttributes(attributes) {\n  // split the string using attributes as the separator\n  var attrs = attributes.split(attributeSeparator());\n  var result = {};\n  var i = attrs.length;\n  var attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nvar ParseStream =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(ParseStream, _Stream);\n\n  function ParseStream() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.customParsers = [];\n    _this.tagMappers = [];\n    return _this;\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  var _proto = ParseStream.prototype;\n\n  _proto.push = function push(line) {\n    var _this2 = this;\n\n    var match;\n    var event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    var newLines = this.tagMappers.reduce(function (acc, mapper) {\n      var mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(function (newLine) {\n      for (var i = 0; i < _this2.customParsers.length; i++) {\n        if (_this2.customParsers[i].call(_this2, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        _this2.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n\n        return;\n      }\n\n      match = /^#EXTINF:?([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'totalduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'byterange'\n        };\n\n        if (match[1]) {\n          event.length = parseInt(match[1], 10);\n        }\n\n        if (match[2]) {\n          event.offset = parseInt(match[2], 10);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MAP:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          var attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            var _attributes$BYTERANGE = attributes.BYTERANGE.split('@'),\n                length = _attributes$BYTERANGE[0],\n                offset = _attributes$BYTERANGE[1];\n\n            event.byterange = {};\n\n            if (length) {\n              event.byterange.length = parseInt(length, 10);\n            }\n\n            if (offset) {\n              event.byterange.offset = parseInt(offset, 10);\n            }\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            var split = event.attributes.RESOLUTION.split('x');\n            var resolution = {};\n\n            if (split[0]) {\n              resolution.width = parseInt(split[0], 10);\n            }\n\n            if (split[1]) {\n              resolution.height = parseInt(split[1], 10);\n            }\n\n            event.attributes.RESOLUTION = resolution;\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        _this2.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-KEY:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-START:?(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        _this2.trigger('data', event);\n\n        return;\n      } // unknown tag type\n\n\n      _this2.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(_ref) {\n    var _this3 = this;\n\n    var expression = _ref.expression,\n        customType = _ref.customType,\n        dataParser = _ref.dataParser,\n        segment = _ref.segment;\n\n    if (typeof dataParser !== 'function') {\n      dataParser = function dataParser(line) {\n        return line;\n      };\n    }\n\n    this.customParsers.push(function (line) {\n      var match = expression.exec(line);\n\n      if (match) {\n        _this3.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType: customType,\n          segment: segment\n        });\n\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(_ref2) {\n    var expression = _ref2.expression,\n        map = _ref2.map;\n\n    var mapFn = function mapFn(line) {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  };\n\n  return ParseStream;\n}(Stream);\n\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @extends Stream\n */\n\nvar Parser =\n/*#__PURE__*/\nfunction (_Stream) {\n  _inheritsLoose(Parser, _Stream);\n\n  function Parser() {\n    var _this;\n\n    _this = _Stream.call(this) || this;\n    _this.lineStream = new LineStream();\n    _this.parseStream = new ParseStream();\n\n    _this.lineStream.pipe(_this.parseStream);\n    /* eslint-disable consistent-this */\n\n\n    var self = _assertThisInitialized(_this);\n    /* eslint-enable consistent-this */\n\n\n    var uris = [];\n    var currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    var currentMap; // if specified, the active decryption key\n\n    var _key;\n\n    var noop = function noop() {};\n\n    var defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    var widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    var currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    _this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    var lastByterangeEnd = 0; // update the manifest with the m3u8 entry from the parse stream\n\n    _this.parseStream.on('data', function (entry) {\n      var mediaGroup;\n      var rendition;\n      ({\n        tag: function tag() {\n          // switch based on the tag type\n          (({\n            'allow-cache': function allowCache() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n            byterange: function byterange() {\n              var byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n            endlist: function endlist() {\n              this.manifest.endList = true;\n            },\n            inf: function inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n            key: function key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                _key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                var VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = {\n                  'com.widevine.alpha': {\n                    attributes: {\n                      schemeIdUri: entry.attributes.KEYFORMAT,\n                      // remove '0x' from the key id string\n                      keyId: entry.attributes.KEYID.substring(2)\n                    },\n                    // decode the base64-encoded PSSH box\n                    pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                  }\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              _key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                _key.iv = entry.attributes.IV;\n              }\n            },\n            'media-sequence': function mediaSequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n            'discontinuity-sequence': function discontinuitySequence() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n            'playlist-type': function playlistType() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n            map: function map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n            },\n            'stream-inf': function streamInf() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n            media: function media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n            discontinuity: function discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n            'program-date-time': function programDateTime() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n            },\n            targetduration: function targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n            },\n            totalduration: function totalduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid total duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.totalDuration = entry.duration;\n            },\n            start: function start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n            'cue-out': function cueOut() {\n              currentUri.cueOut = entry.data;\n            },\n            'cue-out-cont': function cueOutCont() {\n              currentUri.cueOutCont = entry.data;\n            },\n            'cue-in': function cueIn() {\n              currentUri.cueIn = entry.data;\n            }\n          })[entry.tagType] || noop).call(self);\n        },\n        uri: function uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (_key) {\n            currentUri.key = _key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n        comment: function comment() {// comments are not important for playback\n        },\n        custom: function custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n      })[entry.type].call(self);\n    });\n\n    return _this;\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.push = function push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n  ;\n\n  _proto.end = function end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.type         the type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n  ;\n\n  _proto.addParser = function addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n  ;\n\n  _proto.addTagMapper = function addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  };\n\n  return Parser;\n}(Stream);\n\nexport { LineStream, ParseStream, Parser };\n"]},"metadata":{},"sourceType":"module"}